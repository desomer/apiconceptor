import 'dart:developer' as dev show log;
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:jsonschema/core/core_expression.dart';
import 'package:jsonschema/core/api/call_api_manager.dart';

class CallerApi {
  dynamic callGraph() async {
    final options = BaseOptions(
      connectTimeout: Duration(seconds: 30),
      receiveTimeout: Duration(seconds: 30),
    );
    final aDio = Dio(options);
    try {
      final response = await aDio.request(
        'https://spacex-production.up.railway.app/',
        data:
            "{\"query\":\"query ExampleQuery {\\n  company {\\n    ceo\\n  }\\n  roadster {\\n    apoapsis_au\\n  }\\n}\\n\",\"variables\":{},\"operationName\":\"ExampleQuery\"}",
        options: Options(method: 'POST', contentType: 'application/json'),
      );
      print(response);
    } on DioException catch (e) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx and is also not 304.
      if (e.response != null) {
        print(e.response!.data);
        print(e.response!.headers);
        print(e.response!.requestOptions);
      } else {
        // Something happened in setting up or sending the request that triggered an Error
        print(e.requestOptions);
        print(e.message);
      }
    }
  }

  Future<APIResponse> call(APICallManager info, CancelToken cancelToken) async {
    String url = info.url;
    url = info.addParametersOnUrl(url);
    url = info.replaceVarInRequest(url);
    url = url.trim();

    info.logs.add('[SEND] <${info.httpOperation.toUpperCase()}><$url>');
    dev.log('call api <${info.httpOperation.toUpperCase()}><$url>');
    
    var ret = await sendApi(info.httpOperation, url, info.body, cancelToken);
    var httpState = ret.reponse?.statusCode ?? 500;
    var duration = ret.duration;
    var size = ret.size;
    info.logs.add(
      '[RESPONSE] statusCode $httpState ; $size bytes (${getFileSizeString(bytes: size, decimals: 2)}) ; $duration ms',
    );
    return ret;
  }

  Future<APIResponse> sendApi(
    String httpOperation,
    String url,
    dynamic body,
    CancelToken cancelToken,
  ) async {
    final options = BaseOptions(
      connectTimeout: Duration(seconds: 30),
      receiveTimeout: Duration(seconds: 30),
    );
    final aDio = Dio(options);

    var stopWatch = Stopwatch();
    stopWatch.start();
    late APIResponse apiResponse;
    int size = 0;

    try {
      final response = await aDio.request(
        url,
        data: body,
        cancelToken: cancelToken,
        onReceiveProgress: (actualBytes, totalBytes) {
          //print('$actualBytes /  $totalBytes');
          size = actualBytes;
        },
        options: Options(
          method: httpOperation,
          contentType: 'application/json',
          headers: body != null ? {'Content-Type': 'application/json'} : null,
          //responseType: ResponseType.plain,
          validateStatus: (status) {
            return status != null && status >= 200 && status < 300;
          },
        ),
      );
      stopWatch.stop();
      apiResponse = APIResponse(reponse: response);
      apiResponse.size = size;
      apiResponse.duration = stopWatch.elapsed.inMilliseconds;

      response.headers.forEach((key, value) {
        for (final e in value) {
          apiResponse.headers.add({'key': key, 'value': e});
        }
      });

      //print('h ${response.headers}');
      //return apiResponse;
    } on DioException catch (e) {
      stopWatch.stop();
      apiResponse = APIResponse(reponse: e.response);
      apiResponse.size = size;
      apiResponse.duration = stopWatch.elapsed.inMilliseconds;
      if (e.response != null) {
        // print(e.response!.data);
        // print(e.response!.headers);
        // print(e.response!.requestOptions);
        // print(e.response!.statusCode);
        // print(e.response!.statusMessage);
        // if (e.response!.data==null || e.response!.data=='') {
        //   apiResponse.toDisplay = {
        //   'message': 'this data is generated by me',
        //   'statusCode': e.response!.statusCode,
        //   'statusMessage': e.response!.statusMessage,
        // };
        // }
        // return apiResponse;
      } else {
        print(e.requestOptions);
        print(e.message);
        apiResponse.toDisplayError = {'message': e.message};
        // return apiResponse;
      }
    }
    var contentTypeStr = apiResponse.reponse?.headers['content-type'];
    if (contentTypeStr != null && contentTypeStr.isNotEmpty) {
      var ct = ContentType.parse(contentTypeStr.first);
      apiResponse.contentType = ct;
    }
    return apiResponse;
  }
}

class APIResponse {
  final Response? reponse;
  dynamic toDisplayError;
  int duration = 0;
  int size = 0;
  ContentType? contentType;
  List<Map<String, String>> headers = [];

  APIResponse({required this.reponse});
}

class CallScript {
  Future<dynamic> callPreRequest(APICallManager info) async {
    info.requestVariableValue.clear();

    await info.fillVar();

    if (info.preRequestStr.isNotEmpty) {
      CoreExpression run = CoreExpression();
      dynamic r;

      try {
        run.init(info.preRequestStr, logs: info.logs);
        r = await run.eval(
          logs: info.logs,
          variables: info.requestVariableValue,
        );
        print('script return =  $r');
      } catch (e) {
        print(e);
      }

      // for (var element in info.logs) {
      //   print(element);
      // }
      return r;
    }
    info.logs.add('[VARIABLES] ${info.requestVariableValue}');
    return null;
  }
}
